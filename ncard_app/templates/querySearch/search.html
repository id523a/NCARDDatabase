<!DOCTYPE html>
<html lang="en">
{% load crispy_forms_tags %}
<head>
    <meta charset="UTF-8">
    <link href="../../static/css/tableButton.css" type="text/css" rel="stylesheet"/>

    <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>


    <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <link href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.14/dist/js/bootstrap-select.min.js"></script>

    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.14/dist/css/bootstrap-select.min.css">
    <script src="https://www.itxst.com/package/bootstrap-datepicker-1.9.0/js/bootstrap-datepicker.min.js"></script>
    <script src="https://www.itxst.com/package/bootstrap-datepicker-1.9.0/locales/bootstrap-datepicker.zh-CN.min.js"></script>
    <link href="https://www.itxst.com/package/bootstrap-datepicker-1.9.0/css/bootstrap-datepicker.min.css"
          rel="stylesheet">


    <title>Title</title>

    <style>
        .fields {
            display: inline-block;
        }
    </style>
</head>


<body>
<label for="id_select">tables:</label>
<select id="select_table" class="selectpicker" multiple data-live-search="true" data-actions-box="true"
        data-max-options="{{ table_list.keys|length }}">
    {% for table_name in table_list.keys %}
        <option value="{{ table_name }}">{{ table_name }}</option>
    {% endfor %}
    }
</select>


<button id="add_table"> add</button>
<form id="query_form" method="post" action="{% url 'tes' %}">
    {% csrf_token %}
    <button id="report_modal" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myModal" type="button">
        search
    </button>
    {#<input id="query_submit" type="button" value="search">#}
    <div id="table_query">

        {#    {{ form }}#}
    </div>
</form>
<div id="report-area" class="table-responsive">
    <table id="report" class="table table-dark table-striped text-nowrap" style="width: 30%; height: auto;">
        <thead>
        <tr id="report_head">

        </tr>
        </thead>
        <tbody id="report_body">

        </tbody>
    </table>
</div>

</body>

<div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button id="closed" type="button" class="close" data-dismiss="modal"
                        aria-hidden="true">Ã—
                </button>
                <h4 class="modal-title" id="myModalLabel">
                    Choose the report fields
                </h4>
            </div>
            <div id="cutomized_report" class="modal-body">

            </div>
            <div class="modal-footer">
                <button id="close_modal" type="button" class="btn btn-default"
                        data-dismiss="modal">close
                </button>
                <button id="query_submit" type="button" class="btn btn-primary" data-dismiss="modal">
                    search
                </button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->


<script>
    /*
    table_obj : A list to store the ModelForm-related HTML tags for each model returned from the backend,
                and JSON parses these into strings. {table_name :"html tags..."}

   model_obj : A list to store the fields' name for each model,
               which is used for showing the fields for user to customize(in the pop-up window) the column the report must contain.
               and JSON parses these into strings. {table_name : ["field_1","field2"...]}


  dic_display : The table selected by the customer is found in table_obj,
                and the corresponding string is converted into a real HTML object stored in this list,
                so that the value extracted by the key can be directly rendered in the page

  selected_table_fields: Is used to store tables and fields selected by the customer. {table_name:["field_1","field2"...] }
  report_table_filed : Is to record the tables that the user wants to query and the fields that they want to display(by going through the selected check-boxes). {table_name:["field_1","field2"...] }
    */
    const table_obj = JSON.parse("{{ form|escapejs }}");
    const model_obj = JSON.parse("{{ table_list_json|escapejs }}");
    let dic_display = {}
    let selected_table_fields = {}
    let report_table_filed={}

    var table_div = document.getElementById('table_query')



    $("#add_table").click(function () {

        const selected = $("#select_table").val()

        /*
        When the user clicks Add Table,this method generates a div that contains <span> for the table name
        and a drop-down box with options for the table fields
        */


        //Refresh the drop-down box for the table selection
        $("#select_table").val('default').selectpicker("refresh")

        console.log(selected)


        selected.forEach(function (table_name) {
            //If the user has already selected this table, it is invalid and returns directly
            //Prevent adding the same table repeatedly
            if (selected_table_fields.hasOwnProperty(table_name)) {
                return;
            }
            //If not, create a new key-value pair for the table and store it in the 'selected_table_fields' list
            selected_table_fields[table_name] = new Array()

            //Converts the String text of the relevant HTML tags corresponding to the table selected by the customer into the DOM HTML object
            let frag = document.createRange().createContextualFragment(table_obj[table_name])
            //Then create a series of DOM objects
            let div = document.createElement('div')
            let span = document.createElement('span')
            //The hidden input label is intended to return all results by default if the user does not enter any fields
            let hidden_input=document.createElement('input')
            let button = document.createElement('button')
            button.appendChild(document.createTextNode(`add`))
            button.setAttribute('type', 'button')
            //Bind events for buttons so that users add fields for each table
            button.addEventListener('click', function (e) {
                addFiled(e, table_name)
            })
            span.appendChild(document.createTextNode(`table : ${table_name} `))
            span.setAttribute('id', 'table_name')
            hidden_input.setAttribute('name',table_name)
            hidden_input.style.display="none"
            span.appendChild(hidden_input)
            let select = document.createElement('select')
            let initial = document.createElement('option')
            initial.appendChild(document.createTextNode('---------'))
            select.appendChild(initial)
            dic_display[table_name] = {}
            //Create options for the drop-down box of selected table
            frag.querySelectorAll('label').forEach(function (ele) {
                let option = document.createElement('option');
                //Get the name for each field
                let fild_name = ele.innerText.split(":")[0]
                option.appendChild(document.createTextNode(fild_name));
                select.appendChild(option)
                console.log(ele.parentNode)

                //Record the div parent node element corresponding to each field to facilitate the addition of the following fields
                dic_display[table_name][fild_name] = ele.parentNode
            })


            div.appendChild(span)
            div.appendChild(select)
            div.appendChild(button)

            $('#table_query').append(div)

        })


    })
    /*
        This feature is to give the user the ability to add specific fields for each table
    */
    function addFiled(e, table_name) {
        //Gets the drop-down box object
        let select_obj = e.currentTarget.previousSibling
        //Get the value of the field that the client wants to add
        let selected = select_obj.value
        //Refresh the status of the drop-down box
        select_obj.selectedIndex = 0;
        //If the user has added this field before, it is invalid and returns directly
        //Prevent the same field from being generated repeatedly
        if (selected_table_fields[table_name].includes(selected)) {
            return
        }
        //If not, create a new key-value pair for this table to record the selected fields
        selected_table_fields[table_name].push(selected)
        console.log(table_name)
        let dom_obj = dic_display[table_name][selected]
        let button = document.createElement('button')
        button.appendChild(document.createTextNode(`add`))
        button.setAttribute('type', 'button')
        //Bind events for buttons so that users can enter multiple values in each field
        button.addEventListener('click', clone)
        dom_obj.appendChild(button)
        let children = dom_obj.childNodes
        let children_jq = $(children)
        //Wrap the element in a div for subsequent operations
        children_jq.wrapAll("<div class='fields' ></div>")
        e.currentTarget.parentNode.appendChild(dom_obj)

        console.log(e.currentTarget.previousSibling.value)
        call_picker();

    }

    /*
    Call the methods of the front-end plug-in to prevent the front-end plug-in from failing
    */
    function call_picker() {
        var picker = $(".selectpicker")
        Object.values(picker).forEach(function (item) {
            $(item).selectpicker()


        })

        $("[Date-class='year_select']").datepicker({
            format: "yyyy",
            viewMode: "years",
            minViewMode: "years",
            autoclose: true
        })
    }

    /*
        This is the method allowing user to input multiple values in each field (clone the current div element).
    */
    function clone(e) {

        let current_div = e.currentTarget.parentNode
        let current_obj = current_div.cloneNode(true)
        let last_child = current_obj.lastChild

        let second_ele = current_obj.children[1]
        console.log(second_ele)
        second_ele.value = ""
        last_child.remove()

        e.currentTarget.parentNode.parentNode.appendChild(current_obj)
        call_picker();
    }


    $(document).ready(function () {
        $('#query_submit').click(function () {

            /*
            I used ajax to do Asynchronous POST requests, so that the value filled in by the customer can still be retained,
            the whole page is not submitted, and the data is not refreshed. Here I am submitting the values in the form
            */
            $.ajax({
                url: "{% url 'tes' %}",
                type: "post",
                data: $("#query_form").serialize(),
                dataType: "JSON",
                success: function (dataBack) {

                    console.log(dataBack)
                    /*match the query result set from the back end with the columns chosen by the client
                    have to find a decent way for now I am using the if and else  */
                    dataBack.result_set.forEach(function (ele){
                        let array=ele['recipients']
                        let tr=document.createElement('tr')
                        for (var key in report_table_filed){
                            if(key=='award'){
                                report_table_filed[key].forEach(function (award){
                                    let td=document.createElement('td')
                                    let a=document.createElement('a')
                                    let text=ele[`${award}`]
                                    a.appendChild(document.createTextNode(text))
                                    td.appendChild(a)
                                    console.log(ele[`${award}`])
                                    tr.appendChild(td)
                        })
                            }


                        }





                        //For each data, report adds a new row
                        $('#report_body').append(tr)
                     })


                },
                error:function (data) {
                    console.log(data);
                }
            })


        })


        /*
        When the client clicks Search, a modal box pops up. '
        The modal box will then contain the relevant fields of his selected table to provide him with a choice.
        This allows him to decide which columns must be included in the report
         */
        $('#report_modal').click(function () {
            let span_list = document.forms[0].querySelectorAll('#table_name')
            span_list.forEach(function (ele) {
                let table_name = ele.innerText.replace(/\s/g, "").split(":").slice(-1)[0]
                let fields = model_obj[table_name]
                let ul = document.createElement("ul");
                let div = document.createElement('div')
                div.setAttribute("report_customize_table",table_name)
                let head = document.createElement("h3")
                head.appendChild(document.createTextNode(table_name))
                div.appendChild(head)
                fields.forEach(function (field) {

                    let checkbox = document.createElement('input')
                    checkbox.setAttribute("type", "checkbox");
                    checkbox.setAttribute("value", field);
                    let li = document.createElement("li");
                    li.appendChild(checkbox);
                    li.appendChild(document.createTextNode(field))
                    ul.appendChild(li)

                    console.log(field)
                })
                div.appendChild(ul)
                $('#cutomized_report').append(div)
            })


        })
        //When the modal box is closed, empty the contents of the modal box
        $('#myModal').on('hidden.bs.modal', function () {
            $('#cutomized_report').empty()
        });

        $('#closed,#close_modal').click(function () {
            $('#cutomized_report').empty()
        })


        /*When the user selects the field, click Send.
        This function checks which fields have been selected by the user and then populates these fields as table headers for the report
         */
        $('#query_submit').click(function () {
            $('#report_head,#report_body').empty()
            report_table_filed={}
            //get the selected check-boxe
            let checkedBox = document.getElementById('cutomized_report').querySelectorAll('input:checked')
            checkedBox.forEach(function (selected) {
                let column = selected.value
                let th = document.createElement("th")
                let report_table=selected.closest("div").getAttribute("report_customize_table")
                /*I use this list to record the tables that the user wants to query and the fields that they want to display.
                Used to match each column of the report after the result set returned by the back end is obtained*/
                if(!report_table_filed.hasOwnProperty(report_table)){report_table_filed[report_table]=new Array()}
                if(!report_table_filed[report_table].includes(column)){report_table_filed[report_table].push(column)}
                th.appendChild(document.createTextNode(column))
                $('#report_head').append(th)
            })
            $('#cutomized_report').empty()
        })
    })


</script>
</html>